

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Group C</title>
<style type="text/css">
<!--
-->
</style>
<link href="../css/main.css" rel="stylesheet" type="text/css" />
<!--[if lte IE 7]>
<style>
.content { margin-right: -1px; } /* this 1px negative margin can be placed on any of the columns in this layout with the same corrective effect. */
ul.nav a { zoom: 1; }  /* the zoom property gives IE the hasLayout trigger it needs to correct extra whiltespace between the links */
</style>
<![endif]--></head>
<body>

<div class="container">

  <?php include("../includes/header.html"); ?>
  <?php include("../includes/sidebar.html"); ?>

  
  
  <div class="content">
<h1>Final Report - H.Knudsen s0916235</h1><h3 class="c2"><a name="h.7d9ex2kvab5x"></a><span>Introduction </span></h3><p class="c2 c9"><span></span></p>
<p dir="ltr">The project we were assigned was entitled &lsquo;Real-Time Audio Transfer Using a Mesh Network&rsquo; </p>
<p>This title meant that we could start the process of subdividing and allocating tasks amongst the group members almost immediately, due to the fact it would need to consist of numerous logical tasks.</p>
<p class="c1"><span>Our initial idea was to be able to record audio and play it back on another device in real-time, in the same way as a wireless speaker and a microphone might work, but over a mesh network. </span></p><p class="c0"><span></span></p><p class="c1"><span>The project was, for the most part, straightforward but there were some areas which proved more complicated than others. I shall outline the reasons for this deceptive simplicity in the course of the report. </span></p><p class="c0"><span></span></p><p class="c1"><span>The nature of the project resulted in the breakdown of the project&rsquo;s basic problem areas into three specific sections: recording, transferring and playback. Before proceeding it became obvious that there would also need to be sub-parts of these sections, at the very least in the networking section as this part of the project would need to be based on a multi-layered approach. &nbsp;This was due to the fact that, in order to be flexible and adaptable, networking must itself contain different layers. This is a necessity, at least for interfacing across the software and physical radio layer.</span></p><p class="c0">During the project there were a number of areas where I had some involvement these were mainly but not limited to Protocol design &amp; Research, Integration, Testing &amp; Debugging as well as the supporting Website and Final Project Presentation.</p>
<h3 class="c1"><a name="h.3sszejs1ctss"></a><span>The Radio</span></h3><p class="c0"><span></span></p><p class="c1"><span>The radio team was initially based around hardware and routing. This first team started work immediately using sample code provided by Janek Mann in order to be able to write the lowest radio layer so as to be able to send and receive packets of the maximum length allowed by the hardware. </span></p><p class="c0"><span></span></p><p class="c1"><span>During this stage I was involved in the routing design which, at this time, was tasked with finding the best way for packets to be successfully routed and delivered between two points. This necessitated a number of different competing packet designs each optimized with different goals in mind. There were a few options for packet design but our choice was influenced mainly by how a node would start broadcasting, if other nodes would respect this and then if changing any of the physical radio layer settings was a good idea or not. </span></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.p4r2yt7n9a2"></a><span>Mesh Research </span></h3><p class="c0"><span></span></p><p class="c1"><span>The team did some background research on mesh networks and looked at various implementations and found that most mesh networks seem to be based upon an implementation of Open Source Path First which was unnecessary for what we had in mind for, in this design a pre-planned route is taken through the network which is hopefully optimal but has some drawbacks as node locations must be known after which the best route can be taken. </span><span>This design is also only applicable for point to point communication something which we were still unsure about, as we were planning to create a broadcast network. </span></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.avraxuabejyu"></a><span>Point To Point Communication </span></h3><p class="c0"><span></span></p><p class="c1"><span>After the hardware layer was operational we decided to start with point to point transmission, the simplest kind of communication, which would allow us to test the underlying radio layer and make sure we could get a basic transmission working. The first step in testing was to get data to be sent and to generate a packet structure to contain this data. </span></p><p class="c0"><span></span></p><p class="c1"><span>To start, we planned to test with textual data so as not to require other parts of the project to be integrated. This textual data was at first hard coded and rebroadcast on a loop, then inputted from the keyboard using an input library created by a member of our group, of which there were two different versions. The first version was </span><span>blocking</span><span class="c5">,</span><span>&nbsp;meaning that the speck board would have to halt until input was given and, in the other, the input was continuously polled in the main program and the textual input was made available when the enter key was pressed as a variable with a flag notifying that that data had been made available. The main loop would then use this flag to send the data and reset the flag in order to wait for more data. In this way it was possible to send text from the com input of one ProSpeckz board to the com output of another. During testing we found that this worked extremely well both at close range with no antennas, with ~80%+ of the text data making it across the data link but with the caveat that in this setup the boards were simply lying on a desk facing each other and if moved and taken further apart or not point directly at each other packet loss would approach 100% almost immediately. At this stage we started to use antennas and the range gain was immediately evident. With a point to point setup we were able to keep the devices connected anywhere on a level of Appleton Tower but with packet loss increasing at the edge of the range down to unacceptable levels of about 40%.</span></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.5z3qxahapr08"></a><span>Relay Node</span></h3><p class="c0"><span></span></p><p class="c1"><span>After thoroughly testing one way communication we then added a third node setup as a repeater which was setup to repeat packets sent to it from the first node on to a receiver node. Unique packet IDs were used in order to make sure packets were not repeated more than once. These unique IDs were global ID which were made into a circular ID so that an infinite number of packets could be sent and would eventually wrap around when it reached a set limit. We chose 0-</span><span>255 because we could fit it into 1 byte.</span><span>&nbsp;In a larger mesh network this could cause problems but with the size of our network we could assume that the global ID would be successfully propagated with ease. </span></p><p class="c0"><span></span></p><p class="c1"><span>After testing the single repeater setup, we had to stop due to a lack of devices on which to test. This limit on the number of devices we were able to have greatly restricted our testing of a mesh network but, at this stage in testing we could also see that a full mesh network for audio transfer would be impossible due to a problem we faced from the lower hardware layer. This problem arose from the fact that in order for re-transmission to take place the radio had to change mode as it was a &ldquo;Half-Duplex&rdquo; device and therefore only able to operate in a single mode at any one time. The changeover between send and receive also takes a long time. In a continuous data stream from a single point this results in an almost total loss in a single packet relay mode.</span></p><p class="c0"><span></span></p><p class="c1"><span>The diagram below explains why packet relay at high speed was impossible. It is an example of what was occurring but, in actuality, the changeover takes many more packet time periods, &nbsp;therefore increasing the number of lost packets even more. </span></p><p class="c0"><span></span></p><p class="c1"><img height="442" src="images/image05.png" width="602"></p><p class="c0"><span></span></p><p class="c1"><span>This shows why repetition was impossible for real time audio transfer using these devices, i.e because of the time taken for the radio to change mode. Buffered audio and text retransmission were still possible but we decided that for the demonstration it would be better to use a lossy codec and allow for packet loss to take place and use the codec to mask the loss so as to avoid having to use a large buffer and cause a delay. This choice of a lossy codec also meant that it would be difficult to use repetition as with each repetition the audio would become worse due to generation loss. </span></p><p class="c0"><span></span></p><p class="c1"><span>Repetition should not be done with lossy data transmission and therefore some form of acking or Go-Back style protocol would be required in order to implement non lossy transmission. As shown in the diagram above, in situations with packet loss where the radios have to change mode, the data rate will be so low that real time audio transfer becomes untenable. This left us with the option of using large buffers and a complex mesh network, possibly with a synchronized &ldquo;play at&rdquo; command.</span></p><p class="c0"><span></span></p><p class="c1"><span>However, we decided against this option and proceeded with the walkie talkie approach which, we felt, was more interesting and significantly less complex to implement. It did, unfortunately, reduce some of the flexibility that we would have wanted for audio transmissions, namely the loss of repetition and therefore mesh connectivity. </span></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.whh9hyqly85g"></a><span>Separate Protocols </span></h3><p class="c0"><span></span></p><p class="c1"><span>As part of the protocols development we decided that we would use separate protocols for text and audio, due to the constraints placed upon the underlying hardware by realtime audio transfer. This change would allow us to show the development of a mesh network as well as the audio transfer, albeit separately. The text transfer protocol we decided on needed to be &ldquo;reliable&rdquo; to ensure text delivery. In order to do this we decided that we would use multiple delivery attempts in a broadcast fashion in order to attempt reliable delivery, even over a degraded connection. These packets included a checksum and a global ID. The checksum is validated and, if the packet is new, it is repeated multiple times, the idea being that if this system has new text data to send, it will increment the last received global ID and then broadcast the data ten times to in-range nodes, which will then, with any luck, receive at least one broadcast successfully and then attempt to perform the same procedure rebroadcasting the data ten times effectively extending the range over which the data is sent. If data is not received during this broadcast cascade a node will essentially miss out on the data. This is only possible when a node is either out of range of all the other nodes or is offline which</span><span class="c5">&nbsp;</span><span>means that nodes which miss data during its initial broadcast will be unable to obtain it. This was a design decision chosen to make the network simpler by avoiding the need to maintain caches or have a way to request old data.</span></p><p class="c0"><span></span></p><p class="c1"><img height="287" src="images/image06.png" width="370"></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.9skzekaujah4"></a><span>Rudimentary Routing Information Table </span></h3><p class="c0"><span></span></p><p class="c1"><span>This system had some design flaws which could be remedied by the inclusion of periodic sync packets or awareness of what state other nodes are in. Namely that if node packet ID gets out of sync it is possible that the nodes would ignore packets until the ID had incremented all the way around. Having a periodic broadcast would make this less likely and it would also allow nodes to keep a directory of currently active nodes which could be useful in some situations, for example when using chat to find out what nodes are available.</span></p><p class="c0"><span></span></p><p class="c1"><span>As part of one of the early protocol designs, I implemented a system that used a periodic sync as described above in order to make a address book of known devices. Each node was set up and used a hardware counter to broadcast every 10 seconds, a unique ID based upon the time and place of manufacture hardware stamps created during CPU production and permanently stored in the memory on the ProSpekz board. </span><span>The ten second timer required me to instantiate a new timer on the ProSpeckz board as the other timers that were being used were setup to run extremely fast in order to clock the processor and provide timing for recording and playback. </span></p><p class="c0"><span></span></p><p class="c1"><span>See </span><span class="c3"><a class="c8" href="http://forum.energymicro.com/topic/105-unique-id/">http://forum.energymicro.com/topic/105-unique-id/</a></span><span>&nbsp;for an explanation of the hardware IDs. </span></p><p class="c0"><span></span></p><p class="c1"><span>These broadcast were then designed, stored, as well as repeated but only once. In this way each device knew what other devices were in the network, as the packets were designed to be repeatable. The packets were also designed to form a rudimentary Routing Information Protocol (RIP) table but during development we realized that it was unnecessary to implement this design as there would be no use for such routing information and that it was overly complicated for our design. This was a result of our decisions to use direct communication for the audio communication and multiple sends with a checksum for the text broadcasts, thus negating the need for any routing information of this type to be kept or used. </span></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.9rwel5tlxep"></a><span>Recording &amp; Direct Memory Access (DMA)</span></h3><p class="c0"><span></span></p><p class="c1"><span>While the radio protocols were being designed, the development of the other parts of the project was progressing. Luckily one member of our group had worked with Pulse Code Modulation data so it was relatively simple to get a reference sample to test transmission while the microphone was still being worked on. This sample PCM data was recorded on a PC, was stored as an array in the code. This array was also used by the playback team for testing before integration. Each part of the project was pre-tested before integration took place. </span></p><p class="c0"><span></span></p><p class="c1"><span>The recording part of the project was based upon analog microphone and continuous sampling using an Analog Digital Converter (ADC) configured to use the Direct Memory Access (DMA) controller which was set up so that the main processor did not need to wait while the microphone was recording. The DMA would collect one packet&rsquo;s worth of audio data, interrupt the processor which could then process the packet passing the pointer to the data all the way to the radio where it gets sent, thus avoiding using the main processor to collect audio data. This uses the pointer as opposed to copying the data repeatedly and, when copying is required, using the DMA frees up the CPU. &nbsp;A microphone was connected to the ADC </span><span>but an amplifier and voltage shift circuit were needed as the ADC could not read voltages below 0 or tiny fluctuations. </span></p><p class="c0"><span class="c5"></span></p><h3 class="c1"><a name="h.mxkym8yo066d"></a><span>Playback</span></h3><p class="c1"><span>The speaker worked in the reverse way to the microphone whereby data was received by the radio and then sent to a Digital Analog Convertor (DAC) which is the opposite of an ADC. The DAC is based on Pulse Width Modulation (PWM) which is where the output is turned on and off very fast and for different lengths of time. Below is an example of PWM shown on an oscilloscope. </span></p><p class="c0"><span></span></p><p class="c1"><img height="159" src="images/image00.jpg" width="283"><span>Image Credit to Mike Walters</span></p><p class="c0"><span></span></p><p class="c1"><span>When PWM is used at very fast speeds in can effectively reproduce a sound wave. Although it is common to find a high pitched buzzing at the frequency of the PWM, this can be smoothed out and worked extremely well for our project. In order to smooth the PWM one of our group members designed an external circuit with a capacitor which works by taking some time to charge and discharge. We needed to make at least one of these per ProSpeckz for testing so I helped build some of these. </span></p><h3 class="c1"><a name="h.5bryw59pyr43"></a><span>Integration </span></h3><p class="c0"><span></span></p><p class="c1"><span>The final part of the project was the integration required for all the separate parts of the project be put together to run run on one speck board as, until this point, each part of the project had only been tested individually. The audio had been recorded and played back on a PC via the raw PCM, data outputted over the serial console. The reverse had been used to test the playback with captured PCM data being stored as an array and played back directly. The radio had been tested using a dedicated sender which would transmit periodically and which would test the capability of sending a packet. The receiver would then get this and output it to a console thereby testing the receiver.</span></p><p class="c0"><span></span></p><p class="c1"><span>After performing these tests we also experimented with a repeater node. This was done as explained above by repeating individual packets which worked well for text. There was a limitation on text length as it had to be contained within one packet. This also worked and it was at this stage during the integration that we felt all the parts worked and we started testing audio transmission and playback using a dedicated receiver and sender. This worked with relative ease because the radio stack performed so well. Once this was working a lot of time was spent fine tuning the audio quality for both the recording and the playback. <br></span></p><p class="c1"><span>After getting audio to transmit and text to transmit separately, we integrated both into the same code base with different type IDs in order to be able to detect the different types. See below for an example of a packet structure from &ldquo;proto.c&rdquo;</span></p><p class="c0"><span></span></p><p class="c1"><span>typedef struct</span></p><p class="c1"><span>{</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8_t packetID;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5">uint8_t type;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8_t data[30];</span></p><p class="c1"><span>} Packet_Type __attribute__ ((packed));</span></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c1"><span>Up until this stage in the integration we had always had a dedicated pre-programmed mode that each device was in either sender or receiver and different branches in git for text or audio. This was set in code and required separately compiling for each device so we quickly added a small push button switch to a general purpose input output pin. This can be seen in the photo below. </span></p><p class="c1"><img height="202" src="images/image04.jpg" width="359"></p><p class="c1"><span>&ldquo;if ( GPIO_PinInGet(gpioPortD, 10) == 0 ) {</span></p><p class="c1 c4"><span>// Become Audio Sender &amp; Do Audio Sendy Things </span></p><p class="c1"><span>}</span></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.78tj4ehttb69"></a><span>Integration Bugs</span></h3><p class="c0"><span></span></p><p class="c1"><span>This pin combined with a simple statement in the code allowed the devices to transmit both audio and text as well as receive both. At this point, the project seemed complete. Text transmission worked by passing the device&rsquo;s text data over the serial port and text was received the same way but at another device and audio could also be sent back and forth. </span></p><p class="c0"><span></span></p><p class="c1"><span>However, there was a problem in that after sending audio data we discovered that the device would not switch back to receive mode until the device had either been reset or a text packet had been sent. This was the result of a bug which proved difficult to find because of the many different things that could be causing a device not to work and the fact that it only occurred when trying to transmit audio one way and then back and the text transmission appeared to work normally which confused us about the location of the bug. We tried everything we could think of exhaustively checking the code and checking all the attached peripherals, both the recording and playback side. Also during the course of the project we had experienced numerous ProSpeckz board failures, so we tested with other boards. Finally we found out that if transmitted text from a board it would return to a working state where audio could again be received. This was when we realized the problem lay somewhere in the radio stack, so checked the protocol leading us to find out that the bug was somewhere in the hardware radio control. The bug occurs when the radio sends large volumes of data causing it to overload and lock itself into send mode. Because all the different parts of the program had been working and this bug only manifested itself when text was not being used, we diagnosed it quite late into the project and the radio layer was quite specialized and a key part of the project we felt it would be wrong to attempt to diagnose what was wrong so a patch was developed which after sending audio waits for a small amount of time and then sends a &ldquo;blank&rdquo; packet with an invalid ID. This invalid packet is ignored by all other ProSpeckz boards nearby but returns the radio to a working state. The fix is shown below: </span></p><p class="c0"><span></span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; if (need_audio_fix) {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i &gt;= 1000)</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char tmp = &quot;&quot;;</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proto_send((uint8_t *) &amp;tmp, 2);</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_loop();</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_audio_fix = false;</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span></span></p><p class="c1"><span>The fix works by setting the flag need_audio_fix whenever the radio has sent large amounts of data, waiting a short period of time to allow the radio to settle, before sending one fake packet, which then causes the radio to return to its normal state.</span></p><p class="c0"><span></span></p><h3 class="c1"><a name="h.1hfjca1b3pmf"></a><span>Working Final Diagram </span></h3><p class="c0"><span></span></p><p class="c1"><span>This is a diagram of the whole project and its data flow for both audio and text data being sent one way. </span></p><p class="c0"><span></span></p><p class="c1"><img height="378" src="images/image02.png" width="514"></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c1"><span>Notes </span></p><p class="c1"><span>The mic amplification board is used to offset input as ADC can only read positive voltage values and also contains a gain controller to set input amplification used to improve audio recording quality. Output uses PWM which produces a very unclean output so capacitors are used as a low pass filter to smooth the waveform and to clean up the audio quality.</span></p><p class="c0"><span class="c5"></span></p><h3 class="c1"><a name="h.oe8d38u135dj"></a><span>Other Work</span></h3><p class="c1"><span>After the technical project design was completed we also had to </span><span>give a group presentation. We chose to make a Prezi which can be found on bottom of the main page. This went along with the with website which was also created specifically for the project. For the presentation we created a unique display which we thought would be eye catching and slightly humorous for a project such as this, while still displaying our work in professional manner. As we were working with embedded devices we had choice of a few plain cases but we thought it would be more interesting to literally embed our embedded devices inside something more eye catching: a set of hollowed out old books. These were chosen to give a little mystique to the electronics. Below is an image of the two blue books set up as walkie talkies and the green book set up as a mesh repeater for the demonstration.</span></p><h3 class="c1"><a name="h.g5zsbjsvihxz"></a><img height="310" src="images/image01.jpg" width="267"><img height="204" src="images/image03.jpg" width="298"></h3><h3 class="c1 c6"><a name="h.hkfn37nbmge"></a></h3><h3 class="c1"><a name="h.skk3vd3ynb0"></a><span>Conclusion</span><span>&nbsp;</span></h3><p class="c1"><span>The project set out to develope audio transmission over a mesh network on the ProSpekz hardware. This aim was mostly completed successfully and I think can be classified as success. This is because it was quite a difficult task to get audio transfer working on an embedded device especially as it was never designed with such a task. We were really stretching the capabilities of the device at each stage, from the overheads required to record analog audio, to the demands of playback using PWM, not to mention transferring the data in real time over a radio. I do feel it is a shame that we could not broadcast audio over a mesh network and only managed textual data, and, as an extension to the project, I would have like to introduce a protocol with more features such as acknowledgement and the ability to recover data using a Go Back &nbsp;Automatic repeat request (ARQ) protocol. </span></p></body></html>
</body></html></p></body></html>  </div>
  
  
  <?php include("../includes/footer.html"); ?>
